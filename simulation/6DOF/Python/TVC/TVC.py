# TVC.py
import numpy as np
from rocketpy.mathutils.vector_matrix import Matrix, Vector
import math

class TVC:
    """
    Thrust Vector Control (TVC) system for RocketPy.
    This class handles gimbal angles, applies thrust rotation, and computes torque.

    Attributes
    ----------
    TVC.max_gimbal : float
        Maximum gimbal angle (in radians) allowed by the TVC system, converted
        from the specified maximum in degrees.
    TVC.servo_rate : float
        The servo rotation rate (in degrees per second) provided during initialization.
    TVC.gimbal_rate : float
        Actual gimbal rotation rate (in radians per second), computed from the servo
        rate using the scaling factor (1.5/4). This reflects the true rate at which the
        TVC motor can change its gimbal angle.
    TVC.gimbal_angle_x : float
        Current pitch gimbal angle (in radians) of the TVC system (rotation about the Y-axis).
    TVC.gimbal_angle_y : float
        Current yaw gimbal angle (in radians) of the TVC system (rotation about the X-axis).
    TVC.command_history : list
        A list containing the history of commanded gimbal angles along with the simulation time.
    TVC.update_gimbal(pitch_command, yaw_command, dt, time):
        Updates the gimbal angles based on commanded inputs while applying rate limits 
        and maximum deflection constraints, and records the command history.
    TVC.get_thrust_vector(thrust):
        Computes and returns the rotated thrust vector based on the current gimbal angles.
    TVC.get_torque(thrust, nozzle_position):
        Calculates the torque generated by thrust vectoring using the cross-product of 
        the attachment point and the rotated thrust vector.
    TVC.get_gimbal_angles():
        Returns the current gimbal angles for pitch and yaw.
    TVC.reset():
        Resets the gimbal angles to zero.
    """

    def __init__(self, max_gimbal=10, servo_rate=375):
        """
        Initialize TVC system.
        
        Parameters
        -----------
        max_gimbal : float
            Maximum gimbal angle in degrees.
        servo_rate : float
            Maximum servo rotation rate in degrees per second.

        The servo rotation rate does not directly correlate to 
        the gimbal angle of the TVC motor. That must be calculated.
        """

        print("TVC Initialized")

        self.max_gimbal = np.radians(max_gimbal)  # Convert to radians
        self.gimbal_rate = np.radians((1.5/4)*servo_rate)  # Convert servo rate to gimbal rate (rad/s)
        self.gimbal_angle_x = 0.0  # Initial pitch gimbal angle (radians)
        self.gimbal_angle_y = 0.0  # Initial yaw gimbal angle (radians)
        self.command_history = []  # Initialize history for commanded angles

    def update(self, time, state_vector):
        """
        Update TVC system based on the rocket's state.

        Parameters
        ----------
        time : float
            Current simulation time in seconds.
        state_vector : list
            State vector containing the rocket's current state.
        """
        # Extract the LQR controller if available
        if hasattr(self, "controller") and self.controller is not None:
            # Run the controller to get new gimbal commands
            observed_variables = self.controller.update(time, state_vector)

            # Ensure we got valid pitch and yaw commands
            if observed_variables is not None and len(observed_variables) == 2:
                pitch_command, yaw_command = observed_variables
                dt = 1.0 / self.controller.sampling_rate  # Compute time step

                # Update gimbal angles based on control commands
                self.update_gimbal(pitch_command, yaw_command, dt, time)

    
    def update_gimbal(self, pitch_command, yaw_command, dt, time):
        """
        Update gimbal angles based on commanded inputs with rate limits.
        The gimbal is limited to a maximum of 10 degrees in any direction.
        The servo rotation rate is included to simulate the real-time response.
        
        Parameters
        -----------
        pitch_command : float
            Desired pitch gimbal angle in radians.
        yaw_command : float
            Desired yaw gimbal angle in radians.
        dt : float
            Time step for rate limiting in seconds.
        time : float
            Current simulation time in seconds.
        """
        if pitch_command is None:
            pitch_command = self.gimbal_angle_x
        if yaw_command is None:
            yaw_command = self.gimbal_angle_y

        # Convert commands to a Vector (only pitch and yaw, z is zero)
        command_vector = Vector([pitch_command, yaw_command, 0])
        command_magnitude = math.sqrt(command_vector[0]**2 + command_vector[1]**2 + command_vector[2]**2)

        # Enforce maximum gimbal angle (circular constraint)
        if command_magnitude > self.max_gimbal:
            scale_factor = self.max_gimbal / command_magnitude
            command_vector = Vector([
                command_vector[0] * scale_factor,
                command_vector[1] * scale_factor,
                command_vector[2] * scale_factor
            ])

        # Apply rate limiting
        max_step = self.gimbal_rate * dt
        current_vector = Vector([self.gimbal_angle_x, self.gimbal_angle_y, 0])
        delta_vector = command_vector - current_vector
        step_magnitude = math.sqrt(delta_vector[0]**2 + delta_vector[1]**2 + delta_vector[2]**2)
        if step_magnitude > max_step:
            scale_factor = max_step / step_magnitude
            delta_vector = Vector([
                delta_vector[0] * scale_factor,
                delta_vector[1] * scale_factor,
                delta_vector[2] * scale_factor
            ])

        # Update angles
        self.gimbal_angle_x += delta_vector[0]
        self.gimbal_angle_y += delta_vector[1]

        # Record the command history for later plotting
        self.command_history.append((time, self.gimbal_angle_x, self.gimbal_angle_y))

    def get_gimbal_history(self):
        """
        Retrieve stored gimbal angles over time.
        
        Returns
        -------
        list
            List of tuples (time, pitch_angle, yaw_angle) for plotting.
        """
        return self.command_history

    def get_thrust_vector(self, thrust):
        """
        Compute the rotated thrust vector based on current gimbal angles.
        
        Parameters
        -----------
        thrust : float
            Thrust magnitude in Newtons.
        
        Returns
        -------
        Vector
            3D thrust vector in Newtons.
        """

        # Create default thrust vector along +Z in the motor's coordinate system
        thrust_vector = Vector([0, 0, thrust])
        # Create rotation matrices using the current gimbal angles
        R_pitch = Matrix([
            [np.cos(self.gimbal_angle_x), 0, np.sin(self.gimbal_angle_x)],
            [0, 1, 0],
            [-np.sin(self.gimbal_angle_x), 0, np.cos(self.gimbal_angle_x)]
        ])
        R_yaw = Matrix([
            [1, 0, 0],
            [0, np.cos(self.gimbal_angle_y), -np.sin(self.gimbal_angle_y)],
            [0, np.sin(self.gimbal_angle_y), np.cos(self.gimbal_angle_y)]
        ])
        # Apply the rotations: first pitch, then yaw
        rotated_thrust = R_yaw @ (R_pitch @ thrust_vector)

        return rotated_thrust

    def get_torque(self, thrust, nozzle_position):
        """
        Compute torque generated by thrust vectoring.
        
        Parameters
        -----------
        thrust : float
            Thrust magnitude in Newtons.
        nozzle_position : Vector or array-like
            3D position of the attachment point relative to the center of mass (meters).
        
        Returns
        -------
        Vector
            Torque vector in Newton-meters.
        """
        thrust_vector = self.get_thrust_vector(thrust)
        # Ensure nozzle_position is a Vector
        if not isinstance(nozzle_position, Vector):
            nozzle_position = Vector(nozzle_position[0], nozzle_position[1], nozzle_position[2])
        # Compute torque as cross product of attachment point and thrust vector
        return nozzle_position.cross(thrust_vector)

    def get_gimbal_angles(self):
        """
        Return the current gimbal angles.
        
        Returns
        -------
        tuple
            (pitch_angle, yaw_angle) in radians.
        """
        return self.gimbal_angle_x, self.gimbal_angle_y

    def reset(self):
        """
        Reset the gimbal angles to zero.
        """
        self.gimbal_angle_x = 0.0
        self.gimbal_angle_y = 0.0
